



# Not Started





# Moving on to Next Sprint

기능 < 시점

기능 위주: 구현 못해서 미뤄질 가능성 다분



실패? 어떻게 해결?



# 스프린트 회고

각 스프린트 끝날 때 마다



# 이제 뭘 할지

project git flow: 레포에 작성



팀장님, 프로젝트명/팀명





---

주요 요점 정리 
프로젝트 블로깅 하기 (dev-log 사용)

체크인 진행하고 싶습니다 라고
엔지니어분께 연락하면
진행상황 세션진행

기간안에 진행 가능한지 엔지니어분들과 상호 체크

베어 미니멈, 어드밴스드, 나이트메어
이것만큼은 해야한다 / 사실 이만큼 하려했다 / 이정도가 최종 목표

뇌피셜과 현실 비교

일단 프로젝트라는 공동 목표가 있는 상황에서 누가 조금하고 많이하고보다 해내는게 제일 중요해요

블로그 주소를 포함하여, 테이블 채우기
프로젝트명과 팀명 영문으로 정하기 



| imoji     | 설명                                      |
| --------- | ----------------------------------------- |
| :art:     | Improving structure / format of the code. |
| **:zap:** | Improving performance.                    |
| **:bug:** | Fixing a bug.                             |



# git flow

## Git flow

### 브랜치란?

작업 공간 (사본)

사본에는 어떤 작업을 해도 원본에는 영향이 가지 않는다.

브랜치는 여러개 생성할 수 있고, 서로 영향을 미치지 않는다.

→ 새로운 기능을 개발할 때, 원본에 영향을 주지 않고 다양한 시도를 하고 싶을 때



### 브랜치 만들기

현재 나의 위치 확인

'현재 작업 공간'을 베이스로 만들어진다. 내가 현재 작업하고 있는 곳을 항상 확인하자. 작업 공간을 옮기고 싶은데... -> 베이스를 바꾸고 싶은데... -> checkout git checkout 브랜치이름(옮겨가고싶은브랜치)

### 원하는 위치에 자리잡은 후 브랜치 생성

-> 역시 git checkout -b 브랜치명(새로만드는브랜치이름) checkout -b명령으로 새로운 브랜치 생성 + 새로 만들어지는 브랜치로 작업공간 이동 수행됨

### git checkout

head를 옮기는 명령어 head란? 우리가 작업하고 있는 스팟. 현재 내가 어디에서 작업하고 있는가를 나타낸다.

### git branch ---

이 명령어는 새로운 브랜치를 만든다. 하지만 그 브랜치로 head 가 옮겨지지는 않는다.

### git checkout -b ---

이 명령어는 새로운 브랜치를 만들고, 해당 브랜치로 head를 옮긴다.

## git workflow

1. 마스터 레포를 fork 해온다 (마스터 레포 : upstream이라 부름). upstream에는 마스터브랜치와 여러 브랜치가 있을 수 있다. 대부분 개발 브랜치는 dev라고 명명하는듯 하다.
2. fork 해 온 레포를 clone해서 내 로컬로 받는다.
3. upstream과 로컬을 연결하기 : 항상 upstream의 dev브랜치 내용을 최신으로 업데이트 하도록 관리할 것이기 때문에, dev 브랜치 내용은 최신이다. 그래서 로컬의 dev 브랜치를 upstream의 dev 브랜치 내용으로 업데이트 하기 위해, upstream의 dev 브랜치를 pull 해온다. 3-1. 중요 : 나의 remote 레포에서 pull 하는것이 아닌, upstream의 dev를 pull 해 와야 한다. git pull upstream dev
4. 그렇게 pull 해온 최신버전의 코드를 베이스로 해서, 새로운 기능을 만들 새로운 브랜치(예 : feature)를 로컬에 생성한다.
5. 새로 만든 브랜치 (feature)에서 새로운 기능을 개발한다.
6. 기능 구현이 끝나면 해당 브랜치(feature) 를 나의 레포에 push한다.
7. 이후에 upstream에 내가 새로 구현한 기능이 담긴 브랜치(feature) 내용을 풀리퀘스트 한다.
8. upstream 관리자가 풀리퀘를 확인하고 문제가 없다면 머지한다. 그러면 upstream의 dev 브랜치에 내가 새로 만든 기능 코드가 합쳐진다.
9. 이후 또 다른 기능을 개발할 때, dev의 최신상태를 베이스로 해야 하므로 다시 3번부터 시작하여 3~8을 반복한다.

------

> 마스터 레포에 dev 브랜치를 먼저 하나 만들고, 디폴트 브랜치를 dev로 설정. dev는 항상 최신으로 관리. 모두가 최신 dev기준으로 추가 기능을 개발할 것. dev가 모두의 기준이다.

- git pull origin dev 이걸 내 로컬에서 하면 마스터의 dev가 자동으로 오나..???? 헷갈려. 말하자면 fork 해온 나의 레포가, 만약 마스터에 변동이 있으면 자동으로 업데이트되는것임?

> 내가 물어봄 : 내가 업스트림에서 fork 해 온 remote 레포는, 마스터가 업데이트되면 자동으로 업데이트되나요? -> 아님. 머지를 하면 업스트림 dev의 커밋은 점점 늘어날 것. 하지만 나의 remote 레포의 dev는 옛날것임. 그 최신화를 위해서! git pull upstream dev !!!! 해야한다. 나의 remote 레포 dev를 pull 하는 게 아니다!!!! 뭔가 remote 레포의  dev를 최신화시키는 게 리베이스? 라는 듯(부정확)

- git checkout -b addList addList에서 리스트 만드는 작업 진행. 커밋을 잘 해야한다! 꼼꼼히 잘게잘게 나눠서!
- git push origin addList 내 리모트 레포에 addList를 push한다.
- 마스터 레포의 dev로 풀리퀘를 날린다. 풀리퀘스트 형식 알아야겠다

> git push origin dev로 하면 어떤 문제가 있나? : 브랜치명은 어떤 기능을 하고 있는지를 파악하는데 도움이 되기 때문에 기능별 이름을 달아야한다. 파악하기 쉽다. 피알 날릴 때 브랜치 이름을 보면 어떤 기능의 코드인지 알 수 있다.

> 머지할 때 : 우선 코드 리뷰를 하던가 우리만의 룰을 정해서 기준 정해서 머지. 다같이 하는게 좋다. 하루 마무리 시간에(정해서?)

> 머지 하고 나서 개발한 브랜치는 지우라네 : 아까 깃 flow 기능 보니까 자동으로 다 해주더라

### git rebase

나는 한창 작업중인데(3번 상태을 베이스로 작업중이라면) 누가 pr날려서 dev가 머지되어 업데이트 되었다! 그래서 4번상태기 되었다. 나는 어째야하는가... 내가 만약 PR하면? 컨플릭이 난다. 해결책 : rebase -> git rebase dev 이러면 내 베이스가 3번 상태였는데... 4번상태로 바꿔준다. 근데 이걸 하기 전에? git pull upstream dev를 먼저 해서 최신으로 바꿔주고....!

근데 업데이트 된 코드가 내가 작성중인 기능이랑 별루 상관없으면 리베이스 필요없다. 리베이스는 내가 로컬에서 북치고장구치는것