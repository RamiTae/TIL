# [CODESTATES im16] Checkpoint

* **CommonJS**

  * JS언어의 폭을 넓히기 위한 조직, 무브먼트. 서버에서도 JS를 사용하자 > 해결책으로 모듈화를 진행

  * 모듈: 독립적인 작은 코드들이 모여있는 집합. 다른 곳에서 가져다 활용할 수 있는 기능들

  * ES6의 import가 있는데 node.js에서 require를 쓰는 이유

    > https://www.exratione.com/2015/12/es6-use-of-import-property-from-module-is-not-a-great-plan/

* Asynchronous

  * 콜스택

  * 콜백 큐 / 이벤트루프: node.js나 브라우저에서 지원해주는 기능

  * > [이벤트 루프에 대해 시각적으로 잘 표현한 웹앱](http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)

# Q1. CommonJS

```js
var x = 10;
var mod = require('./lib/my-module.js');
var result = mod.x;
```

```js
//in lib/my-module.js
var x = 20;
exports.x = 30;
```

result: 30

> require이 내보내는 것은 exports라는 객체이다.
>
> (exports객체 안에 보내고 싶은 부분을 담는 것임.)

# Q2.  CommonJS

```js
var mod = require('./lib/my-module.js');
var result = mod.x;
```

```js
//in lib/my-module.js:
var x = 10;
exports.x = 20;
module.exports.x = 30;
```

result: 30

> `exports`는 `module.exports`를 참조하는 객체이다.

# Q5. CommonJS

```js
var mod1 = require('./lib/my-module.js');
var mod2 = require('./lib/my-module.js');
```

```js
//lib/my-module.js:
console.log("Loading module!");
```

`console.log`는 한 번 찍힌다!

> `require`을 한 번 실행: 파일 불러오는 것을 한 번 실행.
>
> 여러 번 `require`을 실행하더라도 파일은 한 번만 실행됨.
>
> 캐싱. mod2에서는 mod1에서 한 번 실행했기 때문에 '파일을 실행했다'는 데이터가 저장되어 두 번 실행하지 않음.

# Q9. Asynchronous

```js
console.log("A");

setTimeout(function() {
  console.log("B");
}, 1000);

superLongComputation();

setTimeout(function() {
  console.log("C");
}, 500);

console.log("D");
```

실행되는 순서: A,D,B,C

> `A` 콜스택 > 바로 A출력
>
> `setTimeout(B, 1000)` 웹이면 웹api로, 아니면 node.js에서 처리
>
> `superLongComputation()` 5초 지연: B의 타이머는 끝나서 콜백큐로 넘어간 상태지만 콜스택이 비워지지 않은 상태이기 때문에 B는 콜스택이 비워질때까지 대기한다.
>
> `setTimeout(C, 500)` 5초 지연 후 처리됨. 이 상태에서 B를 실행하는 console은 이미 콜백큐에 들어가 있는 상태이기 때문에(아직 콜스택이 비워지지 않았기 때문에 콜백큐에서 기다리는 상태) B > C순으로 실행됨
>
> `C` 콜스택 > 바로 C출력
>
> ---
>
> setTimeout: 동기적으로 실행되지만 처리가 비동기적이기 때문에 C의 실행은 `superLongComputation()`이후에 실행된다.
>
> 비동기 함수는 아니고 실행은 js에서 동기적으로 진행되지만 실행이 비동기적으로 실행되는 것.